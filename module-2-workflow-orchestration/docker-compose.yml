volumes:
  ny_taxi_postgres_data:
    driver: local
  kestra_postgres_data:
    driver: local
  kestra_data:
    driver: local

services:
  pgdatabase:
    image: postgres:18
    environment:
      POSTGRES_USER: ${NY_TAXI_DB_USER}
      POSTGRES_PASSWORD: ${NY_TAXI_DB_PASSWORD}
      POSTGRES_DB: ${NY_TAXI_DB_NAME}
    ports:
      - "${HOST_LOCAL_IP}:5432:5432"
      - "${HOST_TS_IP}:5432:5432"
    volumes:
      - ny_taxi_postgres_data:/var/lib/postgresql
    depends_on:
      kestra:
        condition: service_started

  pgadmin:
    image: dpage/pgadmin4
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_MAIL}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_PASS}
    ports:
      - "${HOST_LOCAL_IP}:8085:80"
      - "${HOST_TS_IP}:8085:80"
    depends_on:
      pgdatabase:
        condition: service_started

  kestra_postgres:
    image: postgres:18
    volumes:
      - kestra_postgres_data:/var/lib/postgresql
    environment:
      POSTGRES_DB: kestra
      POSTGRES_USER: kestra
      POSTGRES_PASSWORD: ${KESTRA_DB_PASSWORD}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -d $${POSTGRES_DB} -U $${POSTGRES_USER}"]
      interval: 30s
      timeout: 10s
      retries: 10

  kestra:
    image: kestra/kestra:v1.1 # Description: Kestra image version v1.1
    pull_policy: always # Description: Pull always to get the latest image during development
    # Note that this setup with a root user is intended for development purpose.
    # Our base image runs without root, but the Docker Compose implementation needs root to access the Docker socket
    # To run Kestra in a rootless mode in production, see: https://kestra.io/docs/installation/podman-compose
    user: "root" # Description: Run Kestra as root to access the Docker socket
    command: server standalone # Description: Start Kestra in standalone server mode
    volumes:
      - kestra_data:/app/storage # Description: Persistent storage for Kestra data (logs, executions, etc.)
      - /var/run/docker.sock:/var/run/docker.sock # Description: Mount Docker socket to allow Kestra to run Docker tasks
      # Unix-сокет. Руки "дерижера" Кестры должны дотягиваться до Докера на твоём Dell.
      # Слева (Хост): Мы берем настоящую «рацию» твоего компьютера Dell. 
      # Справа (Контейнер): Мы просовываем её внутрь контейнера Kestra по тому же самому адресу.
      # Внутри Кестры уже установлен Docker-клиент. И этот клиент по умолчанию запрограммирован искать «рацию» именно по адресу /var/run/docker.sock. 
      # Если ты примонтируешь его, скажем, в /tmp/my_socket, Кестра его просто не найдет и не сможет запустить ни одну задачу.
      # Зачем это нужно? Кестра — это оркестратор. 
      # Чтобы запустить твой скрипт на Python или команду в dbt, 
      # Кестра сама будет создавать новые контейнеры внутри твоего Докера.
      # Технически то, что мы сделали (через сокет), 
      # в мире системного администрирования называется DooD (Docker outside of Docker).
      # ВНИМАНИЕ (Security Note): Этот сокет — "Мастер-ключ" от твоего Dell.
      # Он дает Кестре права root (суперпользователя) на твоей реальной машине.
      # В продакшене (в банках) так напрямую не делают — используют Socket Proxy 
      # или Rootless Docker, чтобы дирижер случайно не снес всё здание.
      # Но для локальной учебы за роутером — это "золотой стандарт" скорости и удобства.
      - /tmp/kestra-wd:/tmp/kestra-wd # Description: Mount temporary working directory for Kestra tasks (Docker tasks, Python tasks, etc.)
      - ${GCP_KEY_PATH}:/app/gcp-auth.json:ro
    environment:
      # Description: Keatra brains. Configuration for database, storage, authentication, etc.
      GOOGLE_APPLICATION_CREDENTIALS: /app/gcp-auth.json
      KESTRA_CONFIGURATION: |
        # Database configuration using PostgreSQL. Kestra will store its metadata here.
        datasources:
          postgres:
            url: jdbc:postgresql://kestra_postgres:5432/kestra
            driverClassName: org.postgresql.Driver
            username: kestra
            password: ${KESTRA_DB_PASSWORD}
        kestra:
          server:
            basicAuth:
              username: ${KESTRA_USER}
              password: ${KESTRA_PASS}
          # Бухгалтерия Кестры. Твои Flow (YAML-файлы), история запусков 
          # кто, когда и c каким результатом запускал пайплайн и логи
          repository:
            # Почему Postgres: Мы могли бы хранить это в файлах, но база данных позволяет 
            # Кестре мгновенно находить нужный запуск среди тысяч других.
            type: postgres
          storage:
            # Нюанс: в реальном проде (в облаке) тут обычно пишут type: s3 (хранилище Amazon). 
            # Но для твоего Dell «локальный» вариант — самый быстрый и бесплатный.
            type: local
            local:
              # Это полка на складе.
              basePath: "/app/storage"
          queue:
            # Это самое интересное. Кестра состоит из разных частей: 
            # Scheduler (следит за временем), Executor (принимает решения)
            # и Worker (выполняет работу). Им нужно как-то общаться друг с другом.
            # Почему Postgres: В гигантских системах тут используют Kafka или RabbitMQ,
            # но для локальной работы Postgres отлично справляется с ролью «доски объявлений».
            type: postgres
          kestra:
          ai:
            type: "gemini"
            gemini:
              api-key: ${GEMINI_API_KEY}
              model-name: gemini-2.5-flash
          tasks:
            # Верстак. Когда Кестра запускает задачу (например, твой скрипт на Python),
            # ей нужно где-то хранить временные файлы (исходники скрипта, результаты его работы и т.д.)
            tmpDir:
              path: /tmp/kestra-wd/tmp
          # Кестре нужно знать свой собственный адрес, чтобы правильно генерировать ссылки в логах или письмах-уведомлениях.
          url: http://localhost:8080/
    ports:
    # Description: Expose Kestra UI on port 8080 and API on port 8081
      - "${HOST_LOCAL_IP}:8080:8080"
      - "${HOST_TS_IP}:8080:8080"
      - "${HOST_LOCAL_IP}:8081:8081"
      - "${HOST_TS_IP}:8081:8081"
    depends_on:
      # Ensure Kestra starts only after its PostgreSQL database is ready
      kestra_postgres:
        condition: service_started
    